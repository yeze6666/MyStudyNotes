### Git和Github学习

#### 1. 配置Git



#### 2.通过Git提交代码

##### 在当前项目的目录下`git init`，从而实现项目初始化

##### 通过`git add .`将当前代码全部保存到本地缓存区，将工作区中修改的文件保存到缓存区

> 补充：
>
> ```git
> git rm --cached [filename] 
> git rm -r --cached [dir|.]
> //上面2条是从缓存区删除代码文件
> 
> 
> git reset <HEAD|log> [filename]
> // 而这个命令的意思是用版本库中的对应代码文件来替换当前的缓存区，从而实现相同的效果
> ```

##### 通过`git commit -m "第X次代码，XXX地方发生了改动，添加了XX功能"`



#### 3.关于 `git pull` 的作用

是的，`git pull` 会自动将远程仓库中**别人（同事）已经提交并推送到远程的代码**更新到你的本地项目中。比如你在开发 `a` 部分，同事开发 `b、c、d` 并已经通过 `git push` 推到了远程，你执行 `git pull` 后：

- 本地的 `b、c、d` 会被更新为同事的最新版本；
- 你后续调用 `b、c、d` 时，就能用到这些最新代码了。

推荐**只提交自己修改的文件**，而不是用 `git add .`，原因是 `git add .` 会把当前目录下**所有变更**（包括可能的临时文件、本地配置文件等）都加入暂存区，可能不小心提交无关内容。

正确流程：

1.

```git
git add a.java  
# 只添加你开发的a部分文件（可以写多个，用空格分隔）
# 或者更精确：git add src/main/a/ （如果a是一个目录）
```

2.

```git
git commit -m "提交了支付功能（a部分）"  # 注释清晰说明修改内容
```

3.

```git
git pull  # 这一步很重要！确保你的本地代码是最新的，再推送到远程
```



4.

```git
git push -u origin 你的分支名  # 比如 main 或 feature/a-payment
```



>关于 git push -u 的补充 : 
>-u 后面的  应该是分支名（比如 main 主分支，或你自己的开发分支 dev-你的名字）。
>首次推送时用 -u 是为了 “绑定” 本地分支和远程分支，后续推送可以直接简化为 git push。





#### 4.核心命令

1. 初始化仓库：git init vs git clone
    • git init：在本地新建一个空仓库（比如你从零开始写项目时用），执行后会生成一个隐藏的.git文件夹（存储仓库配置和版本历史）。
    • git clone <远程URL>：从远程仓库复制一份到本地（比如别人已经有项目，你要参与开发时用），复制后本地会自动关联这个远程仓库。
2. 提交代码到本地仓库：git add + git commit
    这两个是本地操作，不涉及网络，只影响你自己电脑上的仓库：
    • git add .：将当前工作区（你实际修改的文件）的所有变更，添加到暂存区（可以理解为 “待提交缓冲区”，临时存放你想提交的内容）。
    ◦ 也可以指定文件：git add 文件名（只添加某个文件）。
    • git commit -m "注释"：将暂存区的内容提交到本地仓库，并生成一条版本记录（“注释” 要写清楚这次改了什么，比如 “修复登录按钮 bug”）。
    ◦ 这一步完成后，你的修改就被正式记录在本地仓库的历史中了，但远程仓库还没有更新。
3. 同步到远程仓库：git push
    git push：将本地仓库的提交（就是你用git commit提交的内容）推送到远程仓库，让其他人可以看到你的修改（比如推到 GitHub 上）。
    • 第一次推可能需要指定远程和分支：git push -u origin 分支名（之后可以直接git push）。
4. 获取远程最新代码：git pull
    git pull：从远程仓库拉取最新的代码到本地，并自动合并到你当前的分支（相当于git fetch+git merge的组合）。
    • 作用：多人协作时，别人可能已经推了新代码到远程，你在提交自己的代码前，最好先git pull拉取最新内容，避免冲突。



#### 5.总结协作流程

1. 开始开发前：git pull → 获取同事最新代码，避免一开始就有冲突；
2. 开发中：专注写自己的 a 部分代码；
3. 提交时：git add 你的文件 → git commit -m "清晰注释" → git pull（再次确认无冲突） → git push；
4. 遇到冲突：别怕，解决后再提交即可（冲突是协作的正常现象）。
    这样既能保证你用得到同事的最新代码，也能确保你提交的内容都是自己真正修改的部分，保持仓库整洁～



#### 6.提升篇 ：那怎么从远程仓库中找到全部的版本，有时候我想回调到第X个版本，我应该怎么办？

一、先获取远程仓库的所有版本信息
远程仓库的版本历史不会自动同步到你的本地，需要先 “拉取” 一下（但不是git pull，而是更纯粹的获取历史）：
`git fetch origin  # origin是远程仓库的默认名字，这步会把远程所有版本历史下载到本地`
二、查看所有版本（包括远程的）
执行下面的命令，会列出从最早到最新的所有版本，每个版本有一个唯一的 “版本号”（长串字母数字，比如a1b2c3d）和提交备注：
`git log --oneline --all  # --oneline：简化显示；--all：包括本地和远程的所有版本`
效果类似这样（每一行就是一个版本）：
`a1b2c3d (origin/main) 同事提交的：修复b部分bug  
e4f5g6h 你提交的：完成a部分支付功能  
i7j8k9l 初始版本：项目创建`  
找到你想回退的 “第 X 个版本”，记下它的版本号（比如e4f5g6h）。
三、回退到目标版本
分两种情况，根据你的需求选：
情况 1：只想在本地回到旧版本（不影响远程仓库）
适合你想 “临时查看 / 使用旧版本”，之后可能还要回到最新版本：
`git checkout 版本号  # 比如：git checkout e4f5g6h`
执行后，你的本地文件就会变成这个旧版本的状态。如果想回到最新版本，执行：
`git checkout 你的分支名  # 比如：git checkout main`
情况 2：彻底让本地回到旧版本，并且之后要把这个旧版本推到远程（覆盖远程的最新版本）
谨慎使用！ 会覆盖远程仓库的最新记录，适合确定要 “废弃后面的所有修改” 的场景（比如发现最新版本有严重问题）：

1. 先本地回退：
`git reset --hard 版本号  # 比如：git reset --hard e4f5g6h`
（--hard表示：工作目录的文件也会强制变回旧版本，当前的修改会被清空，务必确认！）
2. 再推送到远程（强制覆盖）：
`git push -f origin 你的分支名  # 比如：git push -f origin main`
（-f是强制推送，会覆盖远程的最新版本，一定要和同事沟通好再用！）
总结
1. 查远程版本：git fetch origin → git log --oneline --all（找版本号）；
2. 本地临时回退：git checkout 版本号；
3. 彻底回退并覆盖远程：git reset --hard 版本号 → git push -f ...（谨慎！）。





